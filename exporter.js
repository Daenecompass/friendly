var credit = "//generated by Friendly v0.1. http://github.com/keithporcaro/friendly (c) 2016 Keith Porcaro (MIT License)"

//yeah yeah this isn't functional style. we'll get there.
var makeTextFile = function (text) {
    var reader = new FileReader();
    var textFile = null
    var packet = entryReplacer(docPackager(), libraryPackager())
    var data = new Blob([byteEncode(credit), '\n', atob(mithrilmin), '\n', atob(rulesengine), '\n', "asker ="+text+";", '\n', atob(wholepacket), byteEncode(packet), byteEncode("}};"), byteEncode ('\n'), byteEncode('m.mount(document.body, asker.QuestionView)')], {type: 'application/javascript'});

    // If we are replacing a previously generated file we need to
    // manually revoke the object URL to avoid memory leaks.
    if (textFile !== null) {
      window.URL.revokeObjectURL(textFile);
    }

    textFile = window.URL.createObjectURL(data);

    return textFile;
};

var assembleFile = function(args){
  var obj = masterPackager(args);
  return obj
}

var docBuffer = function(library){
  var oDoc = docPackager();
  var doc = entryReplacer(oDoc, library) || "";
  return byteEncode(doc)
}

var byteEncode = function(text){
  encoder = new TextEncoder()
  return encoder.encode(text)
}
var masterPackager = function(args){
  var obj = {}
  obj.questions = questionsPackager();
  obj.library = libraryPackager();

  return obj
}

var escapeRegExp = function(stringToGoIntoTheRegex) {
    return stringToGoIntoTheRegex.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
}

function entryReplacer(doc, entries){
  var rDoc = doc || ""
  Object.keys(entries).map(function(entry){
    rDoc = replacer(rDoc, entries[entry].name, entry)
  })
  return " m('.packet', "+rDoc+")"
}

var replacer = function(input, name, id){
  console.log(name)
  var replaceString = ('m("span.var", "'+name+'")')
  var regexed = new RegExp (escapeRegExp(replaceString))
  console.log(regexed)
  var newString = 'm("span.var-'+name+'", ctrl.lib["'+name+'"])'

  return input.replace(regexed, newString)
  /*
  turn into recursive function

templateConverter.Template(marked(doc.vm.doc.content())).replace(/(m\(\"span.var)\", \"([\S]+)\"\)/, "$1[id='$2']\", lib[id])")
  */
}

var removeGetterSetter = function(object){
  var obj = {}
  var keys = Object.keys(object)
  keys.map(function(key){
    obj[key]=object[key]()
  })
  return obj
}


var transformArrayOfObjects = function(objects){
  //Build Questions
  var arr = new Array;
  //question array of objects
  objects.map(function(object){
      var obj = {}
      var keys = Object.keys(object)
        keys.map(function(key){
          var value = object[key]()
          obj[key] = value
        })
        arr.push(obj)
      //composer.vm.list[0][Object.keys(composer.vm.list[0])[0]]()
  })
  return arr
}

//question packager: primary goal is to filter out non-selected fields or choices
var questionsPackager = function(args){
  var qs = []
  var qIds = composer.vm.list;
  var importAnswers = {};
  importAnswers["choices"] = composer.vm.choicesLookup;
  importAnswers["fields"] = composer.vm.fieldsLookup;

  qIds.map(function(qId){
    var q = {}
    q.id = qId
    var attributes = removeGetterSetter(composer.vm.questionAttributes[qId])
    Object.keys(attributes).map(function(key){
      q[key]=attributes[key]
    })
    q[q["type"]] = transformArrayOfObjects(importAnswers[q["type"]][qId]) //must fix to remove gettersetter
    if (composer.vm.questionAttributes[qId].showIf=="true"){
      q["showIf"] = true
    }else{
      q["showIf"] = normalizeNode(composer.vm.ruleTree[qId])
    }

    qs.push(q)
  })

  return qs
}

//library packager: primary goal is to order the value array for each library entry.
//in production, library items will *stop* at the first ruleset in the list that evaluates to true.
var libraryPackager = function(){
  var l = {};
  var libIds = library.vm.list;
  var importAttributes = library.vm.entryLookup;
  var importConditionalValueArrays = library.vm.valueDictionary;
  var importConditionalValueAttributes = library.vm.conditionalValueLookup;


  libIds.map(function(libId){
    l[libId] = {};
    var entryAttributes = removeGetterSetter(importAttributes[libId]);
    Object.keys(entryAttributes).map(function(key){
      l[libId][key]=entryAttributes[key];
    });

    l[libId].conditionalValues=[];
    importConditionalValueArrays[libId].map(function(value){
      var cv = {};
      var cvAttributes = removeGetterSetter(importConditionalValueAttributes[value]);
      Object.keys(cvAttributes).map(function(key){
        cv[key] = cvAttributes[key];
      });
      cv.setIf = normalizeNode(library.vm.ruleTree[value]);
      l[libId].conditionalValues.push(cv);
    });
  });
  return l;
}

//doc packager: modified marked -> mithril view processor -> packetView
var docPackager = function(obj){
  var obj = {}
  var importedDoc = doc.vm.doc.content()
  var markdownConverted = marked(importedDoc)
  obj = new templateConverter.Template(markdownConverted)
  return obj
}



var normalizeNode = function(child, args){
  var norm;
  if (child.type()=="rule"){
    norm = normalizeRuleNode(rules.ruleNode(child.id()))
  } else if(child.type()=="conditional"){
    norm = normalizeConditionalNode(rules.conditionalNode(child.id()), child.id())
  }
  return norm
}

//return an array of children
var formatNodeChildren = function(children){
var arr = [];
  children.map(function(child){
    var norm = normalizeNode(child);
    arr.push(norm)
  })
  return arr
}

var normalizeConditionalNode = function(node, id){
  var obj = {}
  obj[node.condition()] = formatNodeChildren(rules.vm.childList[id]); //remove function dependecy
  return obj
}

var normalizeRuleNode = function(node){
  var obj = {
    name: node.choice(),
    operator: node.operator() || "equalsTo",
    value: node.value() || "true"
  }
  return obj
}
